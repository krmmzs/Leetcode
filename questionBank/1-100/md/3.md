### [3\. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

Difficulty: **给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。   示例 1: 输入: s = "abcabcbb" 输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 示例 2: 输入: s = "bbbbb" 输出: 1 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。 示例 3: 输入: s = "pwwkew" 输出: 3 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。   请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。   提示： 0 <= s.length <= 5 * 104 s 由英文字母、数字、符号和空格组成 **


给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串 **的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**提示：**

*   `0 <= s.length <= 5 * 10<sup>4</sup>`
*   `s` 由英文字母、数字、符号和空格组成


#### Solution

典型的双指针算法

证明：
在暴力$O(n^2)$的情况下
考虑一下单调性

所有情况分为n类，以子串的尾巴分类，可以分为n类
这n类集合里需要加上限制条件：无重复
那么就需要在这n类的集合区域里再找子集
此时来证明单调性

当枚举到i类（以i为尾端点的集合区域）
要找到最长的无重复，说明j（左端点）需要在尽可能左边
可以得知，暴力一定可以找到这样的j

当$i$往右移动到了$i'$
此时j'要么在j的左边要么在j的右边，分类讨论后
假设j'在j的左边
此时形成 j' j i i'的形式
因为j' 到 i'无重复，那么j' 到 i也应该无重复，但是这与i到j是当i为尾端点的最长子串的前提矛盾，所以假设不成立
得出j' 一定会在j的右边
单调性得证

所以i和j都是往后枚举，所以只会走n次

然后用一下哈希表动态维护ij之间每个字符出现的次数

Language: **c++**

```
class Solution {
public:
    int lengthOfLongestSubstring(string s)
    {
        unordered_map<char, int> heap;
        int res = 0;
        for (size_t i = 0, j = 0; i < s.size(); i ++)
        {
            heap[s[i]] ++;
            while (heap[s[i]] > 1)
                heap[s[j ++]] --;
            res = max(res, (int)i - (int)j + 1);
        }

        return res;
    }
};
```
